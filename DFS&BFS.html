<html>
    <body>
        <div class="parent">
            <div class="child-1">
                <div class="child-1-1">
                    <div class="child-1-1-1">
                        a
                    </div>
                </div>
                <div class="child-1-2">
                    <div class="child-1-2-1">
                        b
                    </div>
                </div>
                <div class="child-1-3">
                    c
                </div>
            </div>
            <div class="child-2">
                <div class="child-2-1">
                    <div class="child-2-1-1">
                        d
                    </div>
                </div>
                <div class="child-2-2">
                    <div class="child-2-2-1">
                        e
                    </div>
                </div>
            </div>
            <div class="child-3">
                <div class="child-3-1">
                    f
                </div>
            </div>
        </div>
    </body>
</html>
<script>
// 深度优先
// 1、递归
const deepTraversal1 = node => {
    let nodeList = [];
    if (node !== null) {
        nodeList.push(node);
        let children = node.children;
        for (let i = 0; i < children.length; i++) {
            nodeList.push.apply(nodeList, deepTraversal1(children[i]));
        }
    }
    return nodeList;
}
// 2、循环
// 栈实现，循环中做的是push => pop => push => pop
// 也就是迭代的方式
const deepTraversal2 = (node) => {
    let stack = [];
    let nodes = [];
    if (node) {
        // 推入当前处理的node
        stack.push(node);
        // 栈， 先进后出
        while (stack.length) {
            let item = stack.pop();
            let children = item.children;
            let len = children.length;
            nodes.push(item);
            // 如果有 children，则将 children 入栈，
            // 倒序 push，将最后的 children 放在栈底，每次 pop 最前的的 children，
            for (let i = len - 1; i >= 0; i--) {
                stack.push(children[i]);
            }
        }
    }
    return nodes;
}

const node = document.getElementsByClassName('parent')[0];

// 广度优先
// 队列实现， 循环中做的是push => shift => push => shift
// 也就是迭代的方式
const widthTraversal = node => {
    let queue = [];
    let nodes = [];
    if (node) {
        // 推入当前处理的node
        queue.push(node);
        // 队列， 先进先出
        while (queue.length) {
            // 先 push 的 先出
            let item = queue.shift();
            let children = item.children;
            let len = children.length;
            nodes.push(item);
            // 如果有 children，则将 children 加入队列，
            // 正序加入，则会是一层一层的遍历
            for (let i = 0; i < len; i++) {
                queue.push(children[i]);
            }
        }
    }
    return nodes;
}
console.log('deepTraversal1>>', deepTraversal1(node));
console.log('deepTraversal2>>', deepTraversal2(node));
console.log('widthTraversal>>>', widthTraversal(node));

// 二叉树遍历
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
// 1、递归--深度优先
const preorderTraversal = (root) => {
    const result = [];
    if (root) {
        // 前序遍历
        result.push(root.val);
        result.push.apply(result, preorderTraversal(root.left));
        result.push.apply(result, preorderTraversal(root.right));
        // // 中序遍历
        // result.push.apply(result, preorderTraversal(root.left));
        // result.push(root.val);
        // result.push.apply(result, preorderTraversal(root.right));
        // // 后序遍历
        // result.push.apply(result, preorderTraversal(root.left));
        // result.push.apply(result, preorderTraversal(root.right));
        // result.push(root.val);
    }
    return result;
}
// 2、迭代--广度优先： 队列 前序遍历
const preorderTraversal = (root) => {
    let queue = [];
    let result = [];
    if (root) {
        queue.push(root)
        while (queue.length) {
            let item = queue.shift();
            result.push(item.val);
            if (item.left) queue.push(item.left);
            if (item.right) queue.push(item.right);
        }
    }
    return result;
}

// 3、迭代--深度优先： 栈 前序遍历
const preorderTraversal = (root) => {
    const stack = [];
    const result = [];

    if (root) {
        stack.push(root);
        while (stack.length) {
            let item = stack.pop();
            result.push(item.val);
            // 倒序 push，后 push 的先 pop，即实现前序遍历 L=>D=>R
            if (item.right) stack.push(item.right);
            if (item.left) stack.push(item.left);
        }
    }
    return result;
}
// 4、迭代--后序遍历：栈
// res =>  左 - 右 - 根
// 出 stack 顺序 => 根 - 左 - 右
const preorderTraversal = (root) => {
    const stack = []
    const res = []
    if (root) {
        stack.push(root)
        while (stack.length) {
            let cur = stack.pop()
            res.unshift(cur.val)
            if (cur.left) stack.push(cur.left)
            if (cur.right) stack.push(cur.right)
        }
    }
}
// 5、迭代--中序遍历
// res => 左 - 中 - 右

const preorderTraversal = (root) => {
    const stack = []
    const res = []
    let cur = root
    while (cur || stack.length) {
        // 内层 while 一直找左孩子
        while (cur) {
            stack.push(cur)
            cur = cur.left
        }
        // 取最左的孩子
        cur = stack.pop()
        res.push(cur.val)
        // 尝试读取 cur 的右孩子
        cur = cur.right
    }
    return res
}
</script>